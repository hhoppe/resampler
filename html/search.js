window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "resampler", "modulename": "resampler", "type": "module", "doc": "<p>resampler: fast differentiable resizing and warping of arbitrary grids.</p>\n\n<p><a href=\"https://hhoppe.com/\">Hugues Hoppe</a>\n&nbsp;&nbsp; Aug 2022.</p>\n\n<p><a href=\"https://colab.research.google.com/github/hhoppe/resampler/blob/main/resampler_notebook.ipynb\"><strong>[Open in Colab]</strong></a>\n&nbsp;\n<a href=\"https://www.kaggle.com/notebooks/welcome?src=https://github.com/hhoppe/resampler/blob/main/resampler_notebook.ipynb\"><strong>[Kaggle]</strong></a>\n&nbsp;\n<a href=\"https://mybinder.org/v2/gh/hhoppe/resampler/main?filepath=resampler_notebook.ipynb\"><strong>[MyBinder]</strong></a>\n&nbsp;\n<a href=\"https://deepnote.com/launch?url=https%3A%2F%2Fgithub.com%2Fhhoppe%2Fresampler%2Fblob%2Fmain%2Fresampler_notebook.ipynb\"><strong>[DeepNote]</strong></a>\n&nbsp;\n<a href=\"https://github.com/hhoppe/resampler\"><strong>[GitHub source]</strong></a>\n&nbsp;\n<a href=\"https://hhoppe.github.io/resampler/\"><strong>[API docs]</strong></a>\n&nbsp;\n<a href=\"https://pypi.org/project/resampler/\"><strong>[PyPI package]</strong></a></p>\n\n<p>The Python notebook <a href=\"a href=&quot;https://colab.research.google.com/github/hhoppe/resampler/blob/main/resampler_notebook.ipynb&quot;&gt;https://colab.research.google.com/github/hhoppe/resampler/blob/main/resampler_notebook.ipynb&lt;/a\"><code>resampler_notebook.ipynb</code></a>\nhosts the source code for the\n<a href=\"https://pypi.org/project/resampler/\"><code>resampler</code> package in PyPI</a>,\ninterleaved with documentation, usage examples, unit tests, and signal-processing experiments.</p>\n\n<h1 id=\"overview\">Overview</h1>\n\n<p>The <code>resampler</code> library enables fast differentiable resizing and warping of arbitrary grids.\nIt supports:</p>\n\n<ul>\n<li><p>grids of arbitrary dimension (e.g., 1D audio, 2D images, 3D video, 4D batches of videos),\ncontaining</p></li>\n<li><p>sample values of arbitrary shape\n(e.g., scalars, RGB colors, motion vectors, Jacobian matrices) and</p></li>\n<li><p>arbitrary numeric type (integer, floating, and complex);</p></li>\n<li><p>either <code>dual</code> (\"half-integer\") or <code>primal</code> <strong>grid-type</strong>\nfor each dimension;</p></li>\n<li><p>many <strong>boundary</strong> rules,\nspecified per dimension, extensible via subclassing;</p></li>\n<li><p>an extensible set of parameterized <strong>filter</strong> kernels,\nselectable per dimension;</p></li>\n<li><p>optional <strong>gamma</strong> transfer functions\nfor correct linear-space filtering;</p></li>\n<li><p>prefiltering for accurate antialiasing when downsampling;</p></li>\n<li><p>processing within several <strong>array libraries</strong>\n(<code>numpy</code>, <code>tensorflow</code>, and <code>torch</code>);</p></li>\n<li><p>efficient backpropagation of <strong>gradients</strong>\nfor both <code>tensorflow</code> and <code>torch</code>;</p></li>\n<li><p>easy installation, without any native-code extension module, yet</p></li>\n<li><p><strong>faster resizing</strong> than the C++ implementations\nin <code>tf.image</code>, <code>torch.nn</code>, and <code>torchvision</code>.</p></li>\n</ul>\n\n<p>A key strategy is to build on existing sparse matrix representations and operations.</p>\n\n<h2 id=\"example-usage\">Example usage</h2>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"err\">!</span><span class=\"n\">pip</span> <span class=\"n\">install</span> <span class=\"o\">-</span><span class=\"n\">q</span> <span class=\"n\">mediapy</span> <span class=\"n\">resampler</span>\n<span class=\"kn\">import</span> <span class=\"nn\">mediapy</span> <span class=\"k\">as</span> <span class=\"nn\">media</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">import</span> <span class=\"nn\">resampler</span>\n</code></pre></div>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"n\">rng</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">default_rng</span><span class=\"p\">(</span><span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">array</span> <span class=\"o\">=</span> <span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"p\">((</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>  <span class=\"c1\"># 4x6 RGB image.</span>\n<span class=\"n\">upsampled</span> <span class=\"o\">=</span> <span class=\"n\">resampler</span><span class=\"o\">.</span><span class=\"n\">resize</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"mi\">128</span><span class=\"p\">,</span> <span class=\"mi\">192</span><span class=\"p\">))</span>  <span class=\"c1\"># To 128x192 resolution.</span>\n<span class=\"n\">media</span><span class=\"o\">.</span><span class=\"n\">show_images</span><span class=\"p\">({</span><span class=\"s1\">&#39;4x6&#39;</span><span class=\"p\">:</span> <span class=\"n\">array</span><span class=\"p\">,</span> <span class=\"s1\">&#39;128x192&#39;</span><span class=\"p\">:</span> <span class=\"n\">upsampled</span><span class=\"p\">},</span> <span class=\"n\">height</span><span class=\"o\">=</span><span class=\"mi\">128</span><span class=\"p\">)</span>\n</code></pre></div>\n\n<blockquote>\n  <p><img src=\"https://drive.google.com/uc?export=download&amp;id=1tXm7Z8_ILYpTOsW1a5Z4S-Dvd1vcn7Q5\"/></p>\n</blockquote>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"n\">image</span> <span class=\"o\">=</span> <span class=\"n\">media</span><span class=\"o\">.</span><span class=\"n\">read_image</span><span class=\"p\">(</span><span class=\"s1\">&#39;https://github.com/hhoppe/data/raw/main/image.png&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">downsampled</span> <span class=\"o\">=</span> <span class=\"n\">resampler</span><span class=\"o\">.</span><span class=\"n\">resize</span><span class=\"p\">(</span><span class=\"n\">image</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"mi\">32</span><span class=\"p\">,</span> <span class=\"mi\">32</span><span class=\"p\">))</span>\n<span class=\"n\">media</span><span class=\"o\">.</span><span class=\"n\">show_images</span><span class=\"p\">({</span><span class=\"s1\">&#39;128x128&#39;</span><span class=\"p\">:</span> <span class=\"n\">image</span><span class=\"p\">,</span> <span class=\"s1\">&#39;32x32&#39;</span><span class=\"p\">:</span> <span class=\"n\">downsampled</span><span class=\"p\">},</span> <span class=\"n\">height</span><span class=\"o\">=</span><span class=\"mi\">128</span><span class=\"p\">)</span>\n</code></pre></div>\n\n<blockquote>\n  <p><img src=\"https://drive.google.com/uc?export=download&amp;id=1OiVNvszGZP3COh8mhI0dd2v00cMw2TA0\"/></p>\n</blockquote>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"nn\">plt</span>\n</code></pre></div>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"n\">array</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">3.0</span><span class=\"p\">,</span> <span class=\"mf\">5.0</span><span class=\"p\">,</span> <span class=\"mf\">8.0</span><span class=\"p\">,</span> <span class=\"mf\">7.0</span><span class=\"p\">]</span>  <span class=\"c1\"># 4 source samples in 1D.</span>\n<span class=\"n\">new_dual</span> <span class=\"o\">=</span> <span class=\"n\">resampler</span><span class=\"o\">.</span><span class=\"n\">resize</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"mi\">32</span><span class=\"p\">,))</span>  <span class=\"c1\"># (default gridtype=&#39;dual&#39;) 8x resolution.</span>\n<span class=\"n\">new_primal</span> <span class=\"o\">=</span> <span class=\"n\">resampler</span><span class=\"o\">.</span><span class=\"n\">resize</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"mi\">25</span><span class=\"p\">,),</span> <span class=\"n\">gridtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;primal&#39;</span><span class=\"p\">)</span>  <span class=\"c1\"># 8x resolution.</span>\n<span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">axs</span> <span class=\"o\">=</span> <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">subplots</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">figsize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mf\">1.5</span><span class=\"p\">))</span>\n<span class=\"n\">axs</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">set_title</span><span class=\"p\">(</span><span class=\"s1\">&#39;gridtype dual&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">axs</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">((</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">))</span> <span class=\"o\">+</span> <span class=\"mf\">0.5</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">),</span> <span class=\"n\">array</span><span class=\"p\">,</span> <span class=\"s1\">&#39;o&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">axs</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">((</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">new_dual</span><span class=\"p\">))</span> <span class=\"o\">+</span> <span class=\"mf\">0.5</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">new_dual</span><span class=\"p\">),</span> <span class=\"n\">new_dual</span><span class=\"p\">,</span> <span class=\"s1\">&#39;.&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">axs</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">set_title</span><span class=\"p\">(</span><span class=\"s1\">&#39;gridtype primal&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">axs</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">))</span> <span class=\"o\">/</span> <span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"n\">array</span><span class=\"p\">,</span> <span class=\"s1\">&#39;o&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">axs</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">new_primal</span><span class=\"p\">))</span> <span class=\"o\">/</span> <span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">new_primal</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"n\">new_primal</span><span class=\"p\">,</span> <span class=\"s1\">&#39;.&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</code></pre></div>\n\n<blockquote>\n  <p><img src=\"https://drive.google.com/uc?export=download&amp;id=1VGjyX2nvBKaWyGbrMt3g0Nd3G1YdtFjg\"/></p>\n</blockquote>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"n\">batch_size</span> <span class=\"o\">=</span> <span class=\"mi\">4</span>\n<span class=\"n\">batch_of_images</span> <span class=\"o\">=</span> <span class=\"n\">media</span><span class=\"o\">.</span><span class=\"n\">moving_circle</span><span class=\"p\">((</span><span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"mi\">16</span><span class=\"p\">),</span> <span class=\"n\">batch_size</span><span class=\"p\">)</span>\n<span class=\"n\">upsampled</span> <span class=\"o\">=</span> <span class=\"n\">resampler</span><span class=\"o\">.</span><span class=\"n\">resize</span><span class=\"p\">(</span><span class=\"n\">batch_of_images</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">batch_size</span><span class=\"p\">,</span> <span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"mi\">64</span><span class=\"p\">))</span>\n<span class=\"n\">spacer</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"n\">media</span><span class=\"o\">.</span><span class=\"n\">show_images</span><span class=\"p\">([</span><span class=\"o\">*</span><span class=\"n\">batch_of_images</span><span class=\"p\">,</span> <span class=\"n\">spacer</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">upsampled</span><span class=\"p\">],</span> <span class=\"n\">border</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">height</span><span class=\"o\">=</span><span class=\"mi\">64</span><span class=\"p\">)</span>\n</code></pre></div>\n\n<blockquote>\n  <p><img src=\"https://drive.google.com/uc?export=download&amp;id=1PLHu5mCpmb-_54ybvfr6kLUUTHD6l73t\"/></p>\n</blockquote>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"n\">media</span><span class=\"o\">.</span><span class=\"n\">show_videos</span><span class=\"p\">({</span><span class=\"s1\">&#39;original&#39;</span><span class=\"p\">:</span> <span class=\"n\">batch_of_images</span><span class=\"p\">,</span> <span class=\"s1\">&#39;upsampled&#39;</span><span class=\"p\">:</span> <span class=\"n\">upsampled</span><span class=\"p\">},</span> <span class=\"n\">fps</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</code></pre></div>\n\n<blockquote>\n  <p>original\n  <img src=\"https://drive.google.com/uc?export=download&amp;id=1WCwwbgYZordX14-XvHiV2Gc_60I1KD39\"/>\n  upsampled\n  <img src=\"https://drive.google.com/uc?export=download&amp;id=11Of3Gbv6p2BTxJD2rO0zAWEEv4w3BIe5\"/></p>\n</blockquote>\n\n<p>Most examples above use the default\n<code>resize()</code> settings:</p>\n\n<ul>\n<li><code>gridtype='dual'</code> for both source and destination arrays,</li>\n<li><code>boundary='auto'</code>\nwhich uses <code>'reflect'</code> for upsampling and <code>'clamp'</code> for downsampling,</li>\n<li><code>filter='lanczos3'</code>\n(a <a href=\"https://en.wikipedia.org/wiki/Lanczos_resampling\">Lanczos</a> kernel with radius 3),</li>\n<li><code>gamma=None</code> which by default uses the <code>'power2'</code>\ntransfer function for the <code>uint8</code> image in the second example,</li>\n<li><code>scale=1.0, translate=0.0</code> (no domain transformation),</li>\n<li>default <code>precision</code> and output <code>dtype</code>.</li>\n</ul>\n\n<p><strong>Advanced usage:</strong></p>\n\n<p>Map an image to a wider grid using custom <code>scale</code> and <code>translate</code> vectors,\nwith horizontal <code>'reflect'</code> and vertical <code>'natural'</code> boundary rules,\nproviding a constant value for the exterior,\nusing different filters (Lanczos and O-MOMS) in the two dimensions,\ndisabling gamma correction, performing computations in double-precision,\nand returning an output array in single-precision:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"n\">new</span> <span class=\"o\">=</span> <span class=\"n\">resampler</span><span class=\"o\">.</span><span class=\"n\">resize</span><span class=\"p\">(</span>\n    <span class=\"n\">image</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"mi\">128</span><span class=\"p\">,</span> <span class=\"mi\">512</span><span class=\"p\">),</span> <span class=\"n\">boundary</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"s1\">&#39;natural&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;reflect&#39;</span><span class=\"p\">),</span> <span class=\"n\">cval</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"mf\">0.7</span><span class=\"p\">,</span> <span class=\"mf\">0.3</span><span class=\"p\">),</span>\n    <span class=\"nb\">filter</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"s1\">&#39;lanczos3&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;omoms5&#39;</span><span class=\"p\">),</span> <span class=\"n\">gamma</span><span class=\"o\">=</span><span class=\"s1\">&#39;identity&#39;</span><span class=\"p\">,</span> <span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mf\">0.8</span><span class=\"p\">,</span> <span class=\"mf\">0.25</span><span class=\"p\">),</span>\n    <span class=\"n\">translate</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"mf\">0.35</span><span class=\"p\">),</span> <span class=\"n\">precision</span><span class=\"o\">=</span><span class=\"s1\">&#39;float64&#39;</span><span class=\"p\">,</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;float32&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">media</span><span class=\"o\">.</span><span class=\"n\">show_images</span><span class=\"p\">({</span><span class=\"s1\">&#39;image&#39;</span><span class=\"p\">:</span> <span class=\"n\">image</span><span class=\"p\">,</span> <span class=\"s1\">&#39;new&#39;</span><span class=\"p\">:</span> <span class=\"n\">new</span><span class=\"p\">})</span>\n</code></pre></div>\n\n<blockquote>\n  <p><img src=\"https://drive.google.com/uc?export=download&amp;id=1WUsrghao2Py9hSCPWfinVYg6Lga55h1X\"/></p>\n</blockquote>\n\n<p>Warp an image by transforming it using\n<a href=\"https://en.wikipedia.org/wiki/Polar_coordinate_system\">polar coordinates</a>:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"n\">shape</span> <span class=\"o\">=</span> <span class=\"n\">image</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[:</span><span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"n\">yx</span> <span class=\"o\">=</span> <span class=\"p\">((</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">indices</span><span class=\"p\">(</span><span class=\"n\">shape</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">+</span> <span class=\"mf\">0.5</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"n\">shape</span> <span class=\"o\">-</span> <span class=\"mf\">0.5</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">T</span>  <span class=\"c1\"># [-0.5, 0.5]^2</span>\n<span class=\"n\">radius</span><span class=\"p\">,</span> <span class=\"n\">angle</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linalg</span><span class=\"o\">.</span><span class=\"n\">norm</span><span class=\"p\">(</span><span class=\"n\">yx</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">),</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arctan2</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">yx</span><span class=\"p\">)</span>\n<span class=\"n\">angle</span> <span class=\"o\">+=</span> <span class=\"p\">(</span><span class=\"mf\">0.8</span> <span class=\"o\">-</span> <span class=\"n\">radius</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">clip</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"mf\">2.0</span> <span class=\"o\">-</span> <span class=\"mf\">0.6</span>\n<span class=\"n\">coords</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">dstack</span><span class=\"p\">((</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">angle</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">radius</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">angle</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">radius</span><span class=\"p\">))</span> <span class=\"o\">+</span> <span class=\"mf\">0.5</span>\n<span class=\"n\">resampled</span> <span class=\"o\">=</span> <span class=\"n\">resampler</span><span class=\"o\">.</span><span class=\"n\">resample</span><span class=\"p\">(</span><span class=\"n\">image</span><span class=\"p\">,</span> <span class=\"n\">coords</span><span class=\"p\">,</span> <span class=\"n\">boundary</span><span class=\"o\">=</span><span class=\"s1\">&#39;constant&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">media</span><span class=\"o\">.</span><span class=\"n\">show_images</span><span class=\"p\">({</span><span class=\"s1\">&#39;image&#39;</span><span class=\"p\">:</span> <span class=\"n\">image</span><span class=\"p\">,</span> <span class=\"s1\">&#39;resampled&#39;</span><span class=\"p\">:</span> <span class=\"n\">resampled</span><span class=\"p\">})</span>\n</code></pre></div>\n\n<blockquote>\n  <p><img src=\"https://drive.google.com/uc?export=download&amp;id=1vqnNGeAw5uTNvMEt8hzQY3uXOJugMtJY\"/></p>\n</blockquote>\n\n<p><strong>Limitations:</strong></p>\n\n<ul>\n<li>Filters are assumed to be <a href=\"https://en.wikipedia.org/wiki/Separable_filter\">separable</a>.\nFor rotation equivariance (e.g., bandlimit the signal uniformly in all directions),\nit would be nice to support the (non-separable) 2D rotationally symmetric\n<a href=\"https://en.wikipedia.org/wiki/Sombrero_function\">sombrero function</a>\n$f(\\textbf{x}) = \\text{jinc}(\\|\\textbf{x}\\|)$,\nwhere $\\text{jinc}(r) = 2J_1(\\pi r)/(\\pi r)$.\n(The Fourier transform of a circle\n<a href=\"https://en.wikipedia.org/wiki/Airy_disk\">involves the first-order Bessel function of the first kind</a>.)</li>\n</ul>\n"}, {"fullname": "resampler.ARRAYLIBS", "modulename": "resampler", "qualname": "ARRAYLIBS", "type": "variable", "doc": "<p>Supported array libraries ('numpy', 'tensorflow', and 'torch').</p>\n", "default_value": " = {'numpy': <class 'resampler._NumpyArraylib'>, 'tensorflow': <class 'resampler._TensorflowArraylib'>, 'torch': <class 'resampler._TorchArraylib'>}"}, {"fullname": "resampler.Gridtype", "modulename": "resampler", "qualname": "Gridtype", "type": "class", "doc": "<p>Abstract base class for grid-types such as 'dual' and 'primal'.</p>\n\n<p>In resampling operations, the grid-type may be specified separately as <code>src_gridtype</code> for the\nsource domain and <code>dst_gridtype</code> for the destination domain.  Moreover, the grid-type may be\nspecified per domain dimension.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<blockquote>\n  <p><code>resize(source, shape, gridtype='primal')</code>  # Sets both src and dst.</p>\n  \n  <p><code>resize(source, shape, src_gridtype=['dual', 'primal'],\n       dst_gridtype='dual')</code>  # Source is dual in dim0 and primal in dim1.</p>\n</blockquote>\n"}, {"fullname": "resampler.DualGridtype", "modulename": "resampler", "qualname": "DualGridtype", "type": "class", "doc": "<p>Samples are at the center of cells in a uniform partition of the domain.</p>\n\n<p>For a unit-domain dimension with N samples, each sample 0 &lt;= i &lt;= N has position (i + 0.5) / N,\ne.g., [0.125, 0.375, 0.625, 0.875] for N = 4.</p>\n", "bases": "Gridtype"}, {"fullname": "resampler.PrimalGridtype", "modulename": "resampler", "qualname": "PrimalGridtype", "type": "class", "doc": "<p>Samples are at the vertices of cells in a uniform partition of the domain.</p>\n\n<p>For a unit-domain dimension with N samples, each sample 0 &lt;= i &lt;= N has position i / (N - 1),\ne.g., [0, 1/3, 2/3, 1] for N = 4.</p>\n", "bases": "Gridtype"}, {"fullname": "resampler.GRIDTYPES", "modulename": "resampler", "qualname": "GRIDTYPES", "type": "variable", "doc": "<p>Shortcut names for some predefined grid types, specified per dimension.\nThe two entries are 'dual' and 'primal'.</p>\n", "annotation": ": Dict[str, resampler.Gridtype]", "default_value": " = {'dual': DualGridtype(name='dual'), 'primal': PrimalGridtype(name='primal')}"}, {"fullname": "resampler.Boundary", "modulename": "resampler", "qualname": "Boundary", "type": "class", "doc": "<p>Domain boundary rules.  These define the reconstruction over the source domain near and beyond\nthe domain boundaries.  The rules may be specified separately for each domain dimension.</p>\n"}, {"fullname": "resampler.BOUNDARIES", "modulename": "resampler", "qualname": "BOUNDARIES", "type": "variable", "doc": "<p>Shortcut names for some predefined boundary rules.\nExamples include: 'reflect', 'wrap', 'tile', 'clamp', 'border', etc.</p>\n", "annotation": ": Dict[str, resampler.Boundary]", "default_value": " = {'reflect': Boundary(name='reflect', coord_remap=<resampler.NoRemapCoordinates object>, extend_samples=ReflectExtendSamples(uses_cval=False), override_value=NoOverrideExteriorValue(boundary_antialiasing=True, uses_cval=False), uses_cval=False), 'wrap': Boundary(name='wrap', coord_remap=<resampler.NoRemapCoordinates object>, extend_samples=WrapExtendSamples(uses_cval=False), override_value=NoOverrideExteriorValue(boundary_antialiasing=True, uses_cval=False), uses_cval=False), 'tile': Boundary(name='title', coord_remap=<resampler.TileRemapCoordinates object>, extend_samples=ReflectExtendSamples(uses_cval=False), override_value=NoOverrideExteriorValue(boundary_antialiasing=True, uses_cval=False), uses_cval=False), 'clamp': Boundary(name='clamp', coord_remap=<resampler.NoRemapCoordinates object>, extend_samples=ClampExtendSamples(uses_cval=False), override_value=NoOverrideExteriorValue(boundary_antialiasing=True, uses_cval=False), uses_cval=False), 'border': Boundary(name='border', coord_remap=<resampler.NoRemapCoordinates object>, extend_samples=BorderExtendSamples(uses_cval=True), override_value=NoOverrideExteriorValue(boundary_antialiasing=True, uses_cval=False), uses_cval=True), 'natural': Boundary(name='natural', coord_remap=<resampler.NoRemapCoordinates object>, extend_samples=ValidExtendSamples(uses_cval=True), override_value=UnitDomainOverrideExteriorValue(boundary_antialiasing=True, uses_cval=True), uses_cval=True), 'linear_constant': Boundary(name='linear_constant', coord_remap=<resampler.NoRemapCoordinates object>, extend_samples=LinearExtendSamples(uses_cval=False), override_value=UnitDomainOverrideExteriorValue(boundary_antialiasing=True, uses_cval=True), uses_cval=True), 'quadratic_constant': Boundary(name='quadratic_constant', coord_remap=<resampler.NoRemapCoordinates object>, extend_samples=QuadraticExtendSamples(uses_cval=False), override_value=UnitDomainOverrideExteriorValue(boundary_antialiasing=True, uses_cval=True), uses_cval=True), 'reflect_clamp': Boundary(name='reflect_clamp', coord_remap=<resampler.NoRemapCoordinates object>, extend_samples=ReflectClampExtendSamples(uses_cval=False), override_value=NoOverrideExteriorValue(boundary_antialiasing=True, uses_cval=False), uses_cval=False), 'constant': Boundary(name='constant', coord_remap=<resampler.NoRemapCoordinates object>, extend_samples=ReflectExtendSamples(uses_cval=False), override_value=UnitDomainOverrideExteriorValue(boundary_antialiasing=True, uses_cval=True), uses_cval=True), 'linear': Boundary(name='linear', coord_remap=<resampler.NoRemapCoordinates object>, extend_samples=LinearExtendSamples(uses_cval=False), override_value=NoOverrideExteriorValue(boundary_antialiasing=True, uses_cval=False), uses_cval=False), 'quadratic': Boundary(name='quadratic', coord_remap=<resampler.NoRemapCoordinates object>, extend_samples=QuadraticExtendSamples(uses_cval=False), override_value=NoOverrideExteriorValue(boundary_antialiasing=True, uses_cval=False), uses_cval=False)}"}, {"fullname": "resampler.Filter", "modulename": "resampler", "qualname": "Filter", "type": "class", "doc": "<p>Abstract base class for filter kernel functions.</p>\n\n<p>Each kernel is assumed to be zero-phase filter, i.e., to be symmetric in a support\ninterval [-radius, radius].  (Some sites instead define kernels over the interval [0, N]\nwhere N = 2 * radius.)</p>\n\n<p>Portions of this code are adapted from the C++ library in\n<a href=\"https://github.com/hhoppe/Mesh-processing-library/blob/master/libHh/Filter.cpp\">https://github.com/hhoppe/Mesh-processing-library/blob/master/libHh/Filter.cpp</a></p>\n\n<p>See also <a href=\"http://hhoppe.com/proj/filtering/\">http://hhoppe.com/proj/filtering/</a>.</p>\n"}, {"fullname": "resampler.ImpulseFilter", "modulename": "resampler", "qualname": "ImpulseFilter", "type": "class", "doc": "<p>See <a href=\"https://en.wikipedia.org/wiki/Dirac_delta_function\">https://en.wikipedia.org/wiki/Dirac_delta_function</a>.</p>\n", "bases": "Filter"}, {"fullname": "resampler.BoxFilter", "modulename": "resampler", "qualname": "BoxFilter", "type": "class", "doc": "<p>See <a href=\"https://en.wikipedia.org/wiki/Box_function\">https://en.wikipedia.org/wiki/Box_function</a>.</p>\n\n<p>The kernel function has value 1.0 over the half-open interval [-.5, .5).</p>\n", "bases": "Filter"}, {"fullname": "resampler.TrapezoidFilter", "modulename": "resampler", "qualname": "TrapezoidFilter", "type": "class", "doc": "<p>Filter for antialiased \"area-based\" filtering.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>radius:</strong>  Specifies the support [-radius, radius] of filter, where 0.5 &lt; radius &lt;= 1.0.\nThe special case <code>radius = None</code> is a placeholder that indicates that the filter will be\nreplaced by a trapezoid of the appropriate radius (based on scaling) for correct\nantialiasing in both minification and magnification.</li>\n</ul>\n\n<p>This filter is similar to the BoxFilter but with linearly sloped sides.  It has value 1.0\nin the interval abs(x) &lt;= 1.0 - radius and decreases linearly to value 0.0 in the interval\n1.0 - radius &lt;= abs(x) &lt;= radius, always with value 0.5 at x = 0.5.</p>\n", "bases": "Filter"}, {"fullname": "resampler.TriangleFilter", "modulename": "resampler", "qualname": "TriangleFilter", "type": "class", "doc": "<p>See <a href=\"https://en.wikipedia.org/wiki/Triangle_function\">https://en.wikipedia.org/wiki/Triangle_function</a>.</p>\n\n<p>Also known as the hat or tent function.  It is used for piecewise-linear\n(or bilinear, or trilinear, ...) interpolation.</p>\n", "bases": "Filter"}, {"fullname": "resampler.CubicFilter", "modulename": "resampler", "qualname": "CubicFilter", "type": "class", "doc": "<p>Family of cubic filters parameterized by two scalar parameters.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>b:</strong>  first scalar parameter.</li>\n<li><strong>c:</strong>  second scalar parameter.</li>\n</ul>\n\n<p>See <a href=\"https://en.wikipedia.org/wiki/Mitchell%E2%80%93Netravali_filters\">https://en.wikipedia.org/wiki/Mitchell%E2%80%93Netravali_filters</a> and\n<a href=\"https://doi.org/10.1145/378456.378514\">https://doi.org/10.1145/378456.378514</a>.</p>\n\n<p>[D. P. Mitchell and A. N. Netravali. Reconstruction filters in computer graphics.\nComputer Graphics (Proceedings of ACM SIGGRAPH 1988), 22(4):221-228, 1988.]</p>\n\n<ul>\n<li>The filter has quadratic precision iff b + 2 * c == 1.</li>\n<li>The filter is interpolating iff b == 0.</li>\n<li>(b=1, c=0) is the (non-interpolating) cubic B-spline basis;</li>\n<li>(b=1/3, c=1/3) is the Mitchell filter;</li>\n<li>(b=0, c=0.5) is the Catmull-Rom spline (which has cubic precision);</li>\n<li>(b=0, c=0.75) is the \"sharper cubic\" used in Photoshop and OpenCV.</li>\n</ul>\n", "bases": "Filter"}, {"fullname": "resampler.CatmullRomFilter", "modulename": "resampler", "qualname": "CatmullRomFilter", "type": "class", "doc": "<p>Cubic filter with cubic precision.  Also known as Keys filter.</p>\n\n<p>[E. Catmull, R. Rom.  A class of local interpolating splines.  Computer aided geometric\ndesign, 1974]\n[Wikipedia](https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Catmull%E2%80%93Rom_spline)</p>\n\n<p>[R. G. Keys.  Cubic convolution interpolation for digital image processing.\nIEEE Trans. on Acoustics, Speech, and Signal Processing, 29(6), 1981.]\n<a href=\"https://ieeexplore.ieee.org/document/1163711/\">https://ieeexplore.ieee.org/document/1163711/</a>.</p>\n", "bases": "CubicFilter"}, {"fullname": "resampler.MitchellFilter", "modulename": "resampler", "qualname": "MitchellFilter", "type": "class", "doc": "<p>See <a href=\"https://doi.org/10.1145/378456.378514\">https://doi.org/10.1145/378456.378514</a>.</p>\n\n<p>[D. P. Mitchell and A. N. Netravali.  Reconstruction filters in computer graphics.  Computer\nGraphics (Proceedings of ACM SIGGRAPH 1988), 22(4):221-228, 1988.]</p>\n", "bases": "CubicFilter"}, {"fullname": "resampler.SharpCubicFilter", "modulename": "resampler", "qualname": "SharpCubicFilter", "type": "class", "doc": "<p>Cubic filter that is sharper than Catmull-Rom filter.</p>\n\n<p>Used by some tools including OpenCV and Photoshop.</p>\n\n<p>See <a href=\"https://en.wikipedia.org/wiki/Mitchell%E2%80%93Netravali_filters\">https://en.wikipedia.org/wiki/Mitchell%E2%80%93Netravali_filters</a> and\n<a href=\"http://entropymine.com/resamplescope/notes/photoshop/\">http://entropymine.com/resamplescope/notes/photoshop/</a>.</p>\n", "bases": "CubicFilter"}, {"fullname": "resampler.LanczosFilter", "modulename": "resampler", "qualname": "LanczosFilter", "type": "class", "doc": "<p>High-quality filter: sinc function modulated by a sinc window.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>radius:</strong>  Specifies support window [-radius, radius] over which filter is nonzero.</li>\n<li><strong>sampled:</strong>  If True, use a discretized approximation for improved speed.</li>\n</ul>\n\n<p>See <a href=\"https://en.wikipedia.org/wiki/Lanczos_kernel\">https://en.wikipedia.org/wiki/Lanczos_kernel</a>.</p>\n", "bases": "Filter"}, {"fullname": "resampler.GeneralizedHammingFilter", "modulename": "resampler", "qualname": "GeneralizedHammingFilter", "type": "class", "doc": "<p>Sinc function modulated by a Hamming window.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>radius:</strong>  Specifies support window [-radius, radius] over which filter is nonzero.</li>\n<li><strong>a0:</strong>  Scalar parameter, where 0.0 &lt; a0 &lt; 1.0.  The case of a0=0.5 is the Hann filter.</li>\n</ul>\n\n<p>See <a href=\"https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows\">https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows</a>,\nand hamming() in <a href=\"https://github.com/scipy/scipy/blob/master/scipy/signal/windows/windows.py\">https://github.com/scipy/scipy/blob/master/scipy/signal/windows/windows.py</a>.</p>\n\n<p>Generalized version of np.hamming() and np.hanning().</p>\n", "bases": "Filter"}, {"fullname": "resampler.KaiserFilter", "modulename": "resampler", "qualname": "KaiserFilter", "type": "class", "doc": "<p>Sinc function modulated by a Kaiser-Bessel window.</p>\n\n<p>See <a href=\"https://en.wikipedia.org/wiki/Kaiser_window\">https://en.wikipedia.org/wiki/Kaiser_window</a>, and example use in:\n[Karras et al. 20201.  Alias-free generative adversarial networks.\n<a href=\"https://arxiv.org/pdf/2106.12423.pdf]\">https://arxiv.org/pdf/2106.12423.pdf]</a>.</p>\n\n<p>Use np.kaiser()?</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>radius:</strong>  Value L/2 in the definition.  It may be fractional for a (digital) resizing filter\n(sample spacing s != 1) with an even number of samples (dual grid), e.g., Eq. (6)\nin [Karras et al. 2021] --- this effects the precise shape of the window function.</li>\n<li><strong>beta:</strong>  Determines the trade-off between main-lobe width and side-lobe level.</li>\n<li><strong>sampled:</strong>  If True, use a discretized approximation for improved speed.</li>\n</ul>\n", "bases": "Filter"}, {"fullname": "resampler.BsplineFilter", "modulename": "resampler", "qualname": "BsplineFilter", "type": "class", "doc": "<p>B-spline of a non-negative degree.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>degree:</strong>  The polynomial degree of the B-spline segments.\n<ul>\n<li>With <code>degree=0</code>, it is like <code>BoxFilter</code> except with f(0.5) = f(-0.5) = 0.</li>\n<li>With <code>degree=1</code>, it is identical to <code>TriangleFilter</code>.</li>\n<li>With <code>degree &gt;= 2</code>, it is no longer interpolating.</li>\n</ul></li>\n</ul>\n\n<p>See [Carl de Boor.  A practical guide to splines.  Springer, 2001.]\n<a href=\"https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BSpline.html\">https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.BSpline.html</a></p>\n", "bases": "Filter"}, {"fullname": "resampler.CardinalBsplineFilter", "modulename": "resampler", "qualname": "CardinalBsplineFilter", "type": "class", "doc": "<p>Interpolating B-spline, achieved with aid of digital pre or post filter.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>degree:</strong>  The polynomial degree of the B-spline segments.</li>\n<li><strong>sampled:</strong>  If True, use a discretized approximation for improved speed.</li>\n</ul>\n\n<p>See [Hou and Andrews.  Cubic splines for image interpolation and digital filtering, 1978] and\n[Unser et al.  Fast B-spline transforms for continuous image representation and interpolation,\n1991].</p>\n", "bases": "Filter"}, {"fullname": "resampler.OmomsFilter", "modulename": "resampler", "qualname": "OmomsFilter", "type": "class", "doc": "<p>OMOMS interpolating filter, with aid of digital pre or post filter.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>degree:</strong>  The polynomial degree of the filter segments.</li>\n</ul>\n\n<p>Optimal MOMS (maximal-order-minimal-support) function; see [Blu and Thevenaz, MOMS: Maximal-order\ninterpolation of minimal support, 2001].\n<a href=\"https://infoscience.epfl.ch/record/63074/files/blu0101.pdf\">https://infoscience.epfl.ch/record/63074/files/blu0101.pdf</a></p>\n", "bases": "Filter"}, {"fullname": "resampler.GaussianFilter", "modulename": "resampler", "qualname": "GaussianFilter", "type": "class", "doc": "<p>See <a href=\"https://en.wikipedia.org/wiki/Gaussian_function\">https://en.wikipedia.org/wiki/Gaussian_function</a>.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>standard_deviation:</strong>  Sets the Gaussian $\\sigma$.  The default value is 1.25/3.0, which\ncreates a kernel that is as-close-as-possible to a partition of unity.</li>\n</ul>\n", "bases": "Filter"}, {"fullname": "resampler.NarrowBoxFilter", "modulename": "resampler", "qualname": "NarrowBoxFilter", "type": "class", "doc": "<p>Compact footprint, used for visualization of grid sample location.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>radius:</strong>  Support [-radius, radius] of the narrow box function, with default value 0.199.</li>\n</ul>\n", "bases": "Filter"}, {"fullname": "resampler.FILTERS", "modulename": "resampler", "qualname": "FILTERS", "type": "variable", "doc": "<p>Shortcut names for some predefined filter kernels.  These include 'impulse', 'box', 'trapezoid',\n'triangle', 'cubic', 'lanczos3', 'lanczos5', etc.</p>\n", "annotation": ": Dict[str, resampler.Filter]", "default_value": " = {'impulse': ImpulseFilter(name='impulse', radius=1e-20, interpolating=True, continuous=False, partition_of_unity=False, unit_integral=True, requires_digital_filter=False), 'box': BoxFilter(name='box', radius=0.5, interpolating=True, continuous=False, partition_of_unity=True, unit_integral=True, requires_digital_filter=False), 'trapezoid': TrapezoidFilter(name='trapezoid', radius=0.0, interpolating=True, continuous=True, partition_of_unity=True, unit_integral=True, requires_digital_filter=False), 'triangle': TriangleFilter(name='triangle', radius=1.0, interpolating=True, continuous=True, partition_of_unity=True, unit_integral=True, requires_digital_filter=False), 'cubic': CatmullRomFilter(name='cubic', radius=2.0, interpolating=True, continuous=True, partition_of_unity=True, unit_integral=True, requires_digital_filter=False), 'sharpcubic': SharpCubicFilter(name='sharpcubic', radius=2.0, interpolating=True, continuous=True, partition_of_unity=True, unit_integral=True, requires_digital_filter=False), 'lanczos3': LanczosFilter(name='lanczos_3', radius=3, interpolating=True, continuous=True, partition_of_unity=False, unit_integral=False, requires_digital_filter=False), 'lanczos5': LanczosFilter(name='lanczos_5', radius=5, interpolating=True, continuous=True, partition_of_unity=False, unit_integral=False, requires_digital_filter=False), 'lanczos10': LanczosFilter(name='lanczos_10', radius=10, interpolating=True, continuous=True, partition_of_unity=False, unit_integral=False, requires_digital_filter=False), 'cardinal3': CardinalBsplineFilter(name='cardinal3', radius=2.0, interpolating=True, continuous=True, partition_of_unity=True, unit_integral=True, requires_digital_filter=True), 'cardinal5': CardinalBsplineFilter(name='cardinal5', radius=3.0, interpolating=True, continuous=True, partition_of_unity=True, unit_integral=True, requires_digital_filter=True), 'omoms3': OmomsFilter(name='omoms3', radius=2.0, interpolating=True, continuous=True, partition_of_unity=True, unit_integral=True, requires_digital_filter=True), 'omoms5': OmomsFilter(name='omoms5', radius=3.0, interpolating=True, continuous=True, partition_of_unity=True, unit_integral=True, requires_digital_filter=True), 'hamming3': GeneralizedHammingFilter(name='hamming_3', radius=3, interpolating=True, continuous=True, partition_of_unity=False, unit_integral=False, requires_digital_filter=False), 'kaiser3': KaiserFilter(name='kaiser_3.0_7.12', radius=3.0, interpolating=True, continuous=True, partition_of_unity=False, unit_integral=False, requires_digital_filter=False), 'gaussian': GaussianFilter(name='gaussian_0.417', radius=4.0, interpolating=False, continuous=True, partition_of_unity=False, unit_integral=True, requires_digital_filter=False), 'bspline3': BsplineFilter(name='bspline3', radius=2.0, interpolating=False, continuous=True, partition_of_unity=True, unit_integral=True, requires_digital_filter=False), 'mitchell': MitchellFilter(name='mitchell', radius=2.0, interpolating=False, continuous=True, partition_of_unity=True, unit_integral=True, requires_digital_filter=False), 'narrowbox': NarrowBoxFilter(name='narrowbox', radius=0.199, interpolating=True, continuous=False, partition_of_unity=False, unit_integral=False, requires_digital_filter=False)}"}, {"fullname": "resampler.Gamma", "modulename": "resampler", "qualname": "Gamma", "type": "class", "doc": "<p>Abstract base class for transfer functions on sample values.</p>\n\n<p>Image/video content is often stored using a color component transfer function.\nSee <a href=\"https://en.wikipedia.org/wiki/Gamma_correction\">https://en.wikipedia.org/wiki/Gamma_correction</a>.</p>\n\n<p>Converts between integer types and [0.0, 1.0] internal value range.</p>\n"}, {"fullname": "resampler.IdentityGamma", "modulename": "resampler", "qualname": "IdentityGamma", "type": "class", "doc": "<p>Identity component transfer function.</p>\n", "bases": "Gamma"}, {"fullname": "resampler.PowerGamma", "modulename": "resampler", "qualname": "PowerGamma", "type": "class", "doc": "<p>Gamma correction using a power function.</p>\n", "bases": "Gamma"}, {"fullname": "resampler.SrgbGamma", "modulename": "resampler", "qualname": "SrgbGamma", "type": "class", "doc": "<p>Gamma correction using sRGB; see <a href=\"https://en.wikipedia.org/wiki/SRGB\">https://en.wikipedia.org/wiki/SRGB</a>.</p>\n", "bases": "Gamma"}, {"fullname": "resampler.GAMMAS", "modulename": "resampler", "qualname": "GAMMAS", "type": "variable", "doc": "<p>Shortcut names for some predefined gamma-correction schemes.  These include 'identity',\n'power2', 'power22', and 'srgb'.</p>\n", "annotation": ": Dict[str, resampler.Gamma]", "default_value": " = {'identity': IdentityGamma(name='identity'), 'power2': PowerGamma(name='power_2.0'), 'power22': PowerGamma(name='power_2.2'), 'srgb': SrgbGamma(name='srgb')}"}, {"fullname": "resampler.resize", "modulename": "resampler", "qualname": "resize", "type": "function", "doc": "<p>Resample a grid of sample values onto a grid of different resolution.</p>\n\n<p>The source <code>array</code> may be an array-like, <code>np.ndarray</code>, <code>tf.Tensor</code>, or <code>torch.Tensor</code>.  The\narray is interpreted as a grid with <code>len(shape)</code> domain coordinate dimensions, where each\ngrid sample value has shape <code>array.shape[len(shape):]</code>.</p>\n\n<p>For example:</p>\n\n<ul>\n<li>A grayscale image has <code>array.shape = height, width</code> and resizing it with <code>len(shape) == 2</code>\nproduces a new image of scalar values.</li>\n<li>An RGB image has <code>array.shape = height, width, 3</code> and resizing it with <code>len(shape) == 2</code>\nproduces a new image of RGB values.</li>\n<li>An 3D grid of 3x3 Jacobians has <code>array.shape = Z, Y, X, 3, 3</code> and resizing it with\n<code>len(shape) == 3</code> produces a new 3D grid of Jacobians.</li>\n</ul>\n\n<p>This function also allows scaling and translation from the source domain to the output domain\nthrough the parameters <code>scale</code> and <code>translate</code>.  For more general transforms, see <code>resample</code>.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>array:</strong>  Grid of source sample values.  It must be an array-like object from a library in\n<code>ARRAYLIBS</code>.  The array must have numeric type.  Its first <code>len(shape)</code> dimensions are the\ndomain coordinate dimensions.  Each grid dimension must be at least 1 for a <code>dual</code> grid or\nat least 2 for a <code>primal</code> grid.</li>\n<li><strong>shape:</strong>  The number of grid samples in each coordinate dimension of the output array.  The source\n<code>array</code> must have at least as many dimensions as <code>len(shape)</code>.</li>\n<li><strong>gridtype:</strong>  Placement of samples on both the source and output domain grids, specified as either\na name in <code>GRIDTYPES</code> or a <code>Gridtype</code> instance.  The default is 'dual'.</li>\n<li><strong>src_gridtype:</strong>  Placement of the samples in the source domain grid for each dimension.\nParameters <code>gridtype</code> and <code>src_gridtype</code> cannot both be set.</li>\n<li><strong>dst_gridtype:</strong>  Placement of the samples in the output domain grid for each dimension.\nParameters <code>gridtype</code> and <code>dst_gridtype</code> cannot both be set.</li>\n<li><strong>boundary:</strong>  The reconstruction boundary rule for each dimension in <code>shape</code>, specified as either\na name in <code>BOUNDARIES</code> or a <code>Boundary</code> instance.  The special value 'auto' uses 'reflect'\nfor upsampling and 'clamp' for downsampling.</li>\n<li><strong>cval:</strong>  Constant value used beyond the samples by some boundary rules.  It must be broadcastable\nonto <code>array.shape[len(shape):]</code>.</li>\n<li><strong>filter:</strong>  The reconstruction kernel for each dimension in <code>shape</code>, specified as either a filter\nname in <code>FILTERS</code> or a <code>Filter</code> instance.  It is used during upsampling (i.e., magnification).</li>\n<li><strong>prefilter:</strong>  The prefilter kernel for each dimension in <code>shape</code>, specified as either a filter\nname in <code>FILTERS</code> or a <code>Filter</code> instance.  It is used during downsampling\n(i.e., minification).  If None, it inherits the value of <code>filter</code>.</li>\n<li><strong>gamma:</strong>  Component transfer functions (e.g., gamma correction) applied when reading samples from\n<code>array</code> and when creating output grid samples.  It is specified as either a name in <code>GAMMAS</code>\nor a <code>Gamma</code> instance.  If both <code>array.dtype</code> and <code>dtype</code> are <code>uint</code>, the default is <code>power2</code>.\nIf both are non-<code>uint</code>, the default is <code>identity</code>.  Otherwise, <code>gamma</code> or\n<code>src_gamma</code>/<code>dst_gamma</code> must be set.   Gamma correction assumes that float values are in the\nrange [0.0, 1.0].</li>\n<li><strong>src_gamma:</strong>  Component transfer function used to \"decode\" <code>array</code> samples.\nParameters <code>gamma</code> and <code>src_gamma</code> cannot both be set.</li>\n<li><strong>dst_gamma:</strong>  Component transfer function used to \"encode\" the output samples.\nParameters <code>gamma</code> and <code>dst_gamma</code> cannot both be set.</li>\n<li><strong>scale:</strong>  Scaling factor applied to each dimension of the source domain when it is mapped onto\nthe destination domain.</li>\n<li><strong>translate:</strong>  Offset applied to each dimension of the scaled source domain when it is mapped onto\nthe destination domain.</li>\n<li><strong>precision:</strong>  Inexact precision of intermediate computations.  If None, it is determined based\non <code>array.dtype</code> and <code>dtype</code>.</li>\n<li><strong>dtype:</strong>  Desired data type of the output array.  If None, it is taken to be <code>array.dtype</code>.\nIf it is a uint type, the intermediate float values are rescaled from the [0.0, 1.0] range\nto the uint range.</li>\n<li><strong>dim_order:</strong>  Override the automatically selected order in which the grid dimensions are resized.\nMust contain a permutation of <code>range(len(shape))</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>An array of the same class (<code>np.ndarray</code>, <code>tf.Tensor</code>, or <code>torch.Tensor</code>) as the source <code>array</code>,\n  with shape <code>shape + array.shape[len(shape):]</code> and data type <code>dtype</code>.</p>\n</blockquote>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">resize</span><span class=\"p\">([</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">4.0</span><span class=\"p\">,</span> <span class=\"mf\">5.0</span><span class=\"p\">],</span> <span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">,))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">assert</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">allclose</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mf\">0.74240461</span><span class=\"p\">,</span> <span class=\"mf\">2.88088827</span><span class=\"p\">,</span> <span class=\"mf\">4.68647155</span><span class=\"p\">,</span> <span class=\"mf\">5.02641199</span><span class=\"p\">])</span>\n</code></pre></div>\n", "signature": "(\n    array: Any,\n    shape: Iterable[int],\n    *,\n    gridtype: Union[NoneType, str, resampler.Gridtype] = None,\n    src_gridtype: Union[NoneType, str, resampler.Gridtype, Iterable[Union[str, resampler.Gridtype]]] = None,\n    dst_gridtype: Union[NoneType, str, resampler.Gridtype, Iterable[Union[str, resampler.Gridtype]]] = None,\n    boundary: Union[str, resampler.Boundary, Iterable[Union[str, resampler.Boundary]]] = 'auto',\n    cval: Any = 0,\n    filter: Union[str, resampler.Filter, Iterable[Union[str, resampler.Filter]]] = 'lanczos3',\n    prefilter: Union[NoneType, str, resampler.Filter, Iterable[Union[str, resampler.Filter]]] = None,\n    gamma: Union[NoneType, str, resampler.Gamma] = None,\n    src_gamma: Union[NoneType, str, resampler.Gamma] = None,\n    dst_gamma: Union[NoneType, str, resampler.Gamma] = None,\n    scale: Union[float, Iterable[float]] = 1.0,\n    translate: Union[float, Iterable[float]] = 0.0,\n    precision: Any = None,\n    dtype: Any = None,\n    dim_order: Optional[Iterable[int]] = None,\n    internal_torch_contiguous: bool = True\n) -> Any", "funcdef": "def"}, {"fullname": "resampler.resize_in_numpy", "modulename": "resampler", "qualname": "resize_in_numpy", "type": "function", "doc": "<p>Just like <code>resize()</code> but asserts that the source is a numpy array.</p>\n", "signature": "(array: Any, *args: Any, **kwargs: Any) -> Any", "funcdef": "def"}, {"fullname": "resampler.resize_in_tensorflow", "modulename": "resampler", "qualname": "resize_in_tensorflow", "type": "function", "doc": "<p>Evaluate the <code>resize()</code> operation using Tensorflow's Tensor representation and operations.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>array:</strong>  Grid of source samples, represented as a numpy array.</li>\n<li><strong>*args:</strong>  Parameters for <code>resize()</code>.</li>\n<li><strong>**kwargs:</strong>  Parameters for <code>resize()</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A numpy array.</p>\n</blockquote>\n", "signature": "(array: Any, *args: Any, **kwargs: Any) -> Any", "funcdef": "def"}, {"fullname": "resampler.resize_in_torch", "modulename": "resampler", "qualname": "resize_in_torch", "type": "function", "doc": "<p>Evaluate the <code>resize()</code> operation using Torch's Tensor representation and operations.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>array:</strong>  Grid of source samples, represented as a numpy array.</li>\n<li><strong>*args:</strong>  Parameters for <code>resize()</code>.</li>\n<li><strong>**kwargs:</strong>  Parameters for <code>resize()</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A numpy array.</p>\n</blockquote>\n", "signature": "(array: Any, *args: Any, **kwargs: Any) -> Any", "funcdef": "def"}, {"fullname": "resampler.resample", "modulename": "resampler", "qualname": "resample", "type": "function", "doc": "<p>Interpolate a grid of source samples at specified unit-domain coordinates.</p>\n\n<p>The last dimension of <code>coords</code> contains unit-domain coordinates at which to interpolate the\ndomain grid samples in <code>array</code>.</p>\n\n<p>The number of coordinates (<code>coords.shape[-1]</code>) determines how to interpret <code>array</code>: its first\n<code>coords.shape[-1]</code> dimensions define the grid, and the remaining dimensions describe each grid\nsample (scalar, vector, tensor).</p>\n\n<p>Concretely, the grid has shape <code>array.shape[:coords.shape[-1]]</code> and each grid sample has shape\n<code>array.shape[coords.shape[-1]:]</code>.</p>\n\n<p>Examples include:</p>\n\n<ul>\n<li><p>Resample a grayscale image with <code>array.shape = height, width</code> onto a new grayscale image with\n<code>new.shape = height2, width2</code> by using <code>coords.shape = height2, width2, 2</code>.</p></li>\n<li><p>Resample an RGB image with <code>array.shape = height, width, 3</code> onto a new RGB image with\n<code>new.shape = height2, width2, 3</code> by using <code>coords.shape = height2, width2, 2</code>.</p></li>\n<li><p>Sample an RGB image at <code>num</code> 2D points along a line segment by using <code>coords.shape = num, 2</code>.</p></li>\n<li><p>Sample an RGB image at a single 2D point by using <code>coords.shape = (2,)</code>.</p></li>\n<li><p>Sample a 3D grid of 3x3 Jacobians with <code>array.shape = nz, ny, nx, 3, 3</code> along a 2D plane by\nusing <code>coords.shape = height, width, 3</code>.</p></li>\n<li><p>Map a grayscale image through a color map by using <code>array.shape = 256, 3</code> and\n<code>coords.shape = height, width</code>.</p></li>\n</ul>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>array:</strong>  Grid of source sample values.  It must be an array-like object from a library in\n<code>ARRAYLIBS</code>.  The array must have numeric type.  The coordinate dimensions appear first, and\neach grid sample may have an arbitrary shape.  Each grid dimension must be at least 1 for\na <code>dual</code> grid or at least 2 for a <code>primal</code> grid.</li>\n<li><strong>coords:</strong>  Grid of points at which to resample <code>array</code>.  The point coordinates are in the last\ndimension of <code>coords</code>.  The domain associated with the source grid is a unit hypercube,\ni.e. with a range [0, 1] on each coordinate dimension.  The output grid has shape\n<code>coords.shape[:-1]</code> and each of its grid samples has shape <code>array.shape[coords.shape[-1]:]</code>.</li>\n<li><strong>gridtype:</strong>  Placement of the samples in the source domain grid for each dimension, specified as\neither a name in <code>GRIDTYPES</code> or a <code>Gridtype</code> instance.</li>\n<li><strong>boundary:</strong>  The reconstruction boundary rule for each dimension in <code>coords.shape[-1]</code>, specified\nas either a name in <code>BOUNDARIES</code> or a <code>Boundary</code> instance.  The special value 'auto' uses\n'reflect' for upsampling and 'clamp' for downsampling.</li>\n<li><strong>cval:</strong>  Constant value used beyond the samples by some boundary rules.  It must be broadcastable\nonto the shape <code>array.shape[coords.shape[-1]:]</code>.</li>\n<li><strong>filter:</strong>  The reconstruction kernel for each dimension in <code>coords.shape[-1]</code>, specified as either\na filter name in <code>FILTERS</code> or a <code>Filter</code> instance.</li>\n<li><strong>prefilter:</strong>  The prefilter kernel for each dimension in <code>coords.shape[:-1]</code>, specified as either\na filter name in <code>FILTERS</code> or a <code>Filter</code> instance.  It is used during downsampling\n(i.e., minification).  If None, it inherits the value of <code>filter</code>.</li>\n<li><strong>gamma:</strong>  Component transfer functions (e.g., gamma correction) applied when reading samples\nfrom <code>array</code> and when creating output grid samples.  It is specified as either a name in\n<code>GAMMAS</code> or a <code>Gamma</code> instance.  If both <code>array.dtype</code> and <code>dtype</code> are <code>uint</code>, the default\nis <code>power2</code>.  If both are non-<code>uint</code>, the default is <code>identity</code>.  Otherwise, <code>gamma</code> or\n<code>src_gamma</code>/<code>dst_gamma</code> must be set.   Gamma correction assumes that float values are in the\nrange [0.0, 1.0].</li>\n<li><strong>src_gamma:</strong>  Component transfer function used to \"decode\" <code>array</code> samples.\nParameters <code>gamma</code> and <code>src_gamma</code> cannot both be set.</li>\n<li><strong>dst_gamma:</strong>  Component transfer function used to \"encode\" the output samples.\nParameters <code>gamma</code> and <code>dst_gamma</code> cannot both be set.</li>\n<li><strong>jacobian:</strong>  Optional array, which must be broadcastable onto the shape\n<code>coords.shape[:-1] + (coords.shape[-1], coords.shape[-1])</code>, storing for each point in the\noutput grid the Jacobian matrix of the map from the unit output domain to the unit source\ndomain.  If omitted, it is estimated by computing finite differences on <code>coords</code>.</li>\n<li><strong>precision:</strong>  Inexact precision of intermediate computations.  If None, it is determined based on\n<code>array.dtype</code>, <code>coords.dtype</code>, and <code>dtype</code>.</li>\n<li><strong>dtype:</strong>  Desired data type of the output array.  If None, it is taken to be <code>array.dtype</code>.\nIf it is a uint type, the intermediate float values are rescaled from the [0.0, 1.0] range\nto the uint range.</li>\n<li><strong>max_block_size:</strong>  If nonzero, maximum number of grid points in <code>coords</code> before the resampling\nevaluation gets partitioned into smaller blocks for reduced memory usage and better caching.</li>\n<li><strong>debug:</strong>  Show internal information.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A new sample grid of shape <code>coords.shape[:-1]</code>, represented as an array of shape\n  <code>coords.shape[:-1] + array.shape[coords.shape[-1]:]</code>, of the same array library type as\n  the source array.</p>\n</blockquote>\n\n<p>For reference, the identity resampling for a scalar-valued grid with the default grid-type\n'dual' is:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">array</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">coords</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">moveaxis</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">indices</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">),</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mf\">0.5</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"n\">array</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">new_array</span> <span class=\"o\">=</span> <span class=\"n\">resample</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">,</span> <span class=\"n\">coords</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">assert</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">allclose</span><span class=\"p\">(</span><span class=\"n\">new_array</span><span class=\"p\">,</span> <span class=\"n\">array</span><span class=\"p\">)</span>\n</code></pre></div>\n\n<p>It is more efficient to use the function <code>resize</code> for the special case where the <code>coords</code> are\nobtained as simple scaling and translation of a new regular grid over the source domain:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">scale</span><span class=\"p\">,</span> <span class=\"n\">translate</span><span class=\"p\">,</span> <span class=\"n\">new_shape</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mf\">1.1</span><span class=\"p\">,</span> <span class=\"mf\">1.2</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">0.2</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">coords</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">moveaxis</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">indices</span><span class=\"p\">(</span><span class=\"n\">new_shape</span><span class=\"p\">),</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mf\">0.5</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"n\">new_shape</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">coords</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">coords</span> <span class=\"o\">-</span> <span class=\"n\">translate</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"n\">scale</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">resampled</span> <span class=\"o\">=</span> <span class=\"n\">resample</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">,</span> <span class=\"n\">coords</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">resized</span> <span class=\"o\">=</span> <span class=\"n\">resize</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">,</span> <span class=\"n\">new_shape</span><span class=\"p\">,</span> <span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"n\">scale</span><span class=\"p\">,</span> <span class=\"n\">translate</span><span class=\"o\">=</span><span class=\"n\">translate</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">assert</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">allclose</span><span class=\"p\">(</span><span class=\"n\">resampled</span><span class=\"p\">,</span> <span class=\"n\">resized</span><span class=\"p\">)</span>\n</code></pre></div>\n", "signature": "(\n    array: Any,\n    coords: Any,\n    *,\n    gridtype: Union[str, resampler.Gridtype, Iterable[Union[str, resampler.Gridtype]]] = 'dual',\n    boundary: Union[str, resampler.Boundary, Iterable[Union[str, resampler.Boundary]]] = 'auto',\n    cval: Any = 0,\n    filter: Union[str, resampler.Filter, Iterable[Union[str, resampler.Filter]]] = 'lanczos3',\n    prefilter: Union[NoneType, str, resampler.Filter, Iterable[Union[str, resampler.Filter]]] = None,\n    gamma: Union[NoneType, str, resampler.Gamma] = None,\n    src_gamma: Union[NoneType, str, resampler.Gamma] = None,\n    dst_gamma: Union[NoneType, str, resampler.Gamma] = None,\n    jacobian: Any = None,\n    precision: Any = None,\n    dtype: Any = None,\n    max_block_size: int = 40000,\n    debug: bool = False\n) -> Any", "funcdef": "def"}, {"fullname": "resampler.resample_affine", "modulename": "resampler", "qualname": "resample_affine", "type": "function", "doc": "<p>Resample a source array using an affinely transformed grid of given shape.</p>\n\n<p>The <code>matrix</code> transformation can be linear:\n  source_point = matrix @ destination_point.\nor it can be affine where the last matrix column is an offset vector:\n  source_point = matrix @ (destination_point, 1.0)</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>array:</strong>  Regular grid of source sample values.  The array must have numeric type.  The number of\ngrid dimensions is determined from <code>matrix.shape[0]</code>; the remaining dimensions are for each\nsample value and are all linearly interpolated.</li>\n<li><strong>shape:</strong>  Dimensions of the desired destination grid.  The number of destination grid dimensions\nmay be different from that of the source grid.</li>\n<li><strong>matrix:</strong>  2D array for a linear or affine transform from unit-domain destination points\n(in a space with <code>len(shape)</code> dimensions) into unit-domain source points (in a space with\n<code>matrix.shape[0]</code> dimensions).  If the matrix has <code>len(shape) + 1</code> columns, the last column\nis the affine offset (i.e., translation).</li>\n<li><strong>gridtype:</strong>  Placement of samples on both the source and output domain grids, specified as either\na name in <code>GRIDTYPES</code> or a <code>Gridtype</code> instance.  The default is 'dual'.</li>\n<li><strong>src_gridtype:</strong>  Placement of samples in the source domain grid for each dimension.\nParameters <code>gridtype</code> and <code>src_gridtype</code> cannot both be set.</li>\n<li><strong>dst_gridtype:</strong>  Placement of samples in the output domain grid for each dimension.\nParameters <code>gridtype</code> and <code>dst_gridtype</code> cannot both be set.</li>\n<li><strong>filter:</strong>  The reconstruction kernel for each dimension in <code>matrix.shape[0]</code>, specified as either\na filter name in <code>FILTERS</code> or a <code>Filter</code> instance.</li>\n<li><strong>prefilter:</strong>  The prefilter kernel for each dimension in <code>len(shape)</code>, specified as either\na filter name in <code>FILTERS</code> or a <code>Filter</code> instance.  It is used during downsampling\n(i.e., minification).  If None, it inherits the value of <code>filter</code>.</li>\n<li><strong>precision:</strong>  Inexact precision of intermediate computations.  If None, it is determined based\non <code>array.dtype</code> and <code>dtype</code>.</li>\n<li><strong>dtype:</strong>  Desired data type of the output array.  If None, it is taken to be <code>array.dtype</code>.\nIf it is a uint type, the intermediate float values are rescaled from the [0.0, 1.0] range\nto the uint range.</li>\n<li><strong>**kwargs:</strong>  Additional parameters for <code>resample</code> function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>An array of the same class (<code>np.ndarray</code>, <code>tf.Tensor</code>, or <code>torch.Tensor</code>) as the source <code>array</code>,\n  representing a grid with specified <code>shape</code>, where each grid value is resampled from <code>array</code>.\n  Thus the shape of the returned array is <code>shape + array.shape[matrix.shape[0]:]</code>.</p>\n</blockquote>\n", "signature": "(\n    array: Any,\n    shape: Iterable[int],\n    matrix: Any,\n    *,\n    gridtype: Union[NoneType, str, resampler.Gridtype] = None,\n    src_gridtype: Union[NoneType, str, resampler.Gridtype, Iterable[Union[str, resampler.Gridtype]]] = None,\n    dst_gridtype: Union[NoneType, str, resampler.Gridtype, Iterable[Union[str, resampler.Gridtype]]] = None,\n    filter: Union[str, resampler.Filter, Iterable[Union[str, resampler.Filter]]] = 'lanczos3',\n    prefilter: Union[NoneType, str, resampler.Filter, Iterable[Union[str, resampler.Filter]]] = None,\n    precision: Any = None,\n    dtype: Any = None,\n    **kwargs: Any\n) -> Any", "funcdef": "def"}, {"fullname": "resampler.resize_using_resample", "modulename": "resampler", "qualname": "resize_using_resample", "type": "function", "doc": "<p>Use the more general <code>resample</code> operation for <code>resize</code>, as a debug tool.</p>\n", "signature": "(\n    array: Any,\n    shape: Iterable[int],\n    *,\n    scale: Any = 1.0,\n    translate: Any = 0.0,\n    fallback: bool = False,\n    **kwargs: Any\n) -> Any", "funcdef": "def"}, {"fullname": "resampler.rotation_about_center_in_2d", "modulename": "resampler", "qualname": "rotation_about_center_in_2d", "type": "function", "doc": "<p>Return the 3x3 matrix mapping destination into a source unit domain.</p>\n\n<p>The returned matrix accounts for the possibly non-square domain shapes.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>src_shape:</strong>  Resolution (ny, nx) of the source domain grid.</li>\n<li><strong>angle:</strong>  Angle in radians (positive from x to y axis) applied when mapping the source domain\nonto the destination domain.</li>\n<li><strong>dst_shape:</strong>  Resolution (ny, nx) of the destination domain grid; it defaults to <code>src_shape</code>.</li>\n<li><strong>scale:</strong>  Scaling factor applied when mapping the source domain onto the destination domain.</li>\n</ul>\n", "signature": "(\n    src_shape: Any,\n    angle: float,\n    dst_shape: Any = None,\n    scale: float = 1.0\n) -> Any", "funcdef": "def"}, {"fullname": "resampler.rotate_image_about_center", "modulename": "resampler", "qualname": "rotate_image_about_center", "type": "function", "doc": "<p>Return a copy of <code>image</code> rotated about its center.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>image:</strong>  Source grid samples; the first two dimensions are spatial (ny, nx).</li>\n<li><strong>angle:</strong>  Angle in radians (positive from x to y axis) applied when mapping the source domain\nonto the destination domain.</li>\n<li><strong>new_shape:</strong>  Resolution (ny, nx) of the output grid; it defaults to <code>image.shape[:2]</code>.</li>\n<li><strong>scale:</strong>  Scaling factor applied when mapping the source domain onto the destination domain.</li>\n<li><strong>num_rotations:</strong>  Number of rotations (each by <code>angle</code>).  Successive resamplings are useful in\nanalyzing the filtering quality.</li>\n<li><strong>**kwargs:</strong>  Additional parameters for <code>resample_affine</code>.</li>\n</ul>\n", "signature": "(\n    image: Any,\n    angle: float,\n    new_shape: Any = None,\n    scale: float = 1.0,\n    num_rotations: int = 1,\n    **kwargs: Any\n) -> Any", "funcdef": "def"}, {"fullname": "resampler.pil_image_resize", "modulename": "resampler", "qualname": "pil_image_resize", "type": "function", "doc": "<p>Invoke <code>PIL.Image.resize</code> using the same parameters as <code>resize</code>.</p>\n", "signature": "(array: Any, shape: Sequence[int], filter: str) -> Any", "funcdef": "def"}, {"fullname": "resampler.cv_resize", "modulename": "resampler", "qualname": "cv_resize", "type": "function", "doc": "<p>Invoke <code>cv.resize</code> using the same parameters as <code>resize</code>.</p>\n", "signature": "(array: Any, shape: Sequence[int], filter: str) -> Any", "funcdef": "def"}, {"fullname": "resampler.tf_image_resize", "modulename": "resampler", "qualname": "tf_image_resize", "type": "function", "doc": "<p>Invoke <code>tf.image.resize</code> using the same parameters as <code>resize</code>.</p>\n", "signature": "(\n    array: Any,\n    shape: Sequence[int],\n    filter: str = 'lanczos3',\n    antialias: bool = True\n) -> Any", "funcdef": "def"}, {"fullname": "resampler.torch_nn_resize", "modulename": "resampler", "qualname": "torch_nn_resize", "type": "function", "doc": "<p>Invoke <code>torch.nn.functional.interpolate</code> using the same parameters as <code>resize</code>.</p>\n", "signature": "(\n    array: Any,\n    shape: Sequence[int],\n    filter: str,\n    antialias: bool = False\n) -> Any", "funcdef": "def"}, {"fullname": "resampler.torchvision_resize", "modulename": "resampler", "qualname": "torchvision_resize", "type": "function", "doc": "<p>Invoke <code>torchvision.transforms.functional.resize</code> using the same parameters as <code>resize</code>.</p>\n", "signature": "(\n    array: Any,\n    shape: Sequence[int],\n    filter: str,\n    antialias: Optional[bool] = None\n) -> Any", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();